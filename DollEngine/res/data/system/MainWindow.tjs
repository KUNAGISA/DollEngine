
class KAGWindow extends Window
{
	////////////////////////
	//基本属性
	var scWidth=960;//画面的逻辑宽高
	var scHeight=640;
	var readOnlyMode=false;//是否存在存档机制（和变量存储不同）
	var saveThumbnail=false;//截图是否另存一份缩略图
	var thumbnailWidth = 240;//截图缩略图宽度
	var saveDataID = "";//存档用的加密key
	var saveDataMode = "c";//加密模式
	var numCharacterLayers = 3;
	var numMessageLayers = 3;
	var numMovies = 1;
	var numSEBuffers = 3;
	var currentNum = 0; //默认的文字层ID

	////////////////////////
	//剧本相关
	var kagController;//KAGParser
	var tagHandlers=%[];//KagTags
	//文字显示速度
	var chSpeeds = %[
		fast : 30,
		normal : 100,
		slow : 300,
	];
	//角色立绘的初始位置
	var scPositionX = %[
		left : 120,
		left_center : 240,
		center : 480,
		right_center :600,
		right : 720,
	];
	var autoModePageWaits=%[];
	var autoModeLineWaits=%[];
	var numBookMarks=10;//最大存档数
	var showBookMarkDate = true;// 记录存档时是否也记录时间
	var helpFile="";//帮助文本文件

	var defStyle = %[		//剧本文字默认样式
		chSpeed:chSpeeds.normal,			//文字显示速度模式
		charSpacing:0, 		//文字间距
		lineSpacing:5, 	//行间距
	];
	var defFont = %[ 	//剧本文字默认字体
		face:"",		//字体名
		height:24,		//字体大小
	];

	////////////////////////
	//成员对象
	var mainWindow;
	var sysbase;
	var fore;
	var back;
	var current;
	var mainTouch;

	////////////////////////
	//状态机
	var isLinking=false;
	var waitStatus = 0;//0:nowait 1:textDrawing 2:UIControlDrawing 3:trans 4:action 5:waittime
	var skipByNoWait = false;
	var skipByClick = false;
	function KAGWindow ()
	{
		super.Window();
		(KAGWindow_config incontextof this)();
		(KAGWindow_config_override incontextof this)()
			if typeof global.KAGWindow_config_override != "undefined";
		setLayerSize(scWidth,scHeight);
		setInnerSize(scWidth,scHeight);
		initWidget();
		// kagController = new Controller(this);

		// sysbase = new BaseLayer(this,null);
		// fore = new StageLayer(this,sysbase);
		// back = new StageLayer(this,sysbase);
		// fore.mirroredLayer = back;
		// back.mirroredLayer = fore;
		// fore.absolute = 1;
		// fore.visible = true;
		// back.visible = false;
		// back.absolute = 0;

		// fore.getLayer(numCharacterLayers-1);
		// current = fore.getMessage(numMessageLayers-1);
		// current = fore.messages[0];
		// currentNum = 0;
		// current.visible=true;

		// mainTouch = new TouchEvent();
		// mainTouch.onClick = onClick;
		// mainTouch.enabled = true;
	}

	function finalize () 
	{
		invalidate kagController;
		super.finalize();
	}

	function assign (src) 
	{
		super.assign(src);
	}

	function getMessageLayerObjectFromElm (elm) 
	{
		var page = elm.page;
		var layer = elm.layer;
		if(page === void && layer === void) return current;
		var base;
		if(page == 'back') base = back; else base = fore;
		if(layer === void || layer == 'message') return base.getMessage(currentNum);
		return base.getMessage(+layer.substr(7));
	}

	function getLayerFromElm (elm) 
	{
		var base;
		if(elm['page'] == 'back') base = back; else base = fore;
		var layer = elm['layer'];
		if(layer == 'base') return base.base; // 背景
		if(layer[0] == 'm')
		{
			if(layer == 'message') return base.getMessage(currentNum);
			return base.getMessage(+layer.substr(7));
		}
		return base.getLayer(+layer);
	}

	function getMessageLayerPageFromElm(elm)
	{
		// elm から該当する表/裏画面のメッセージレイヤ配列を返す
		if (elm.page == "back")
		{
			return "back";
		}
		else
		{
			return "fore";
		}
	}

	function getMessageLayerNumberFromElm(elm)
	{
		var layer = elm.layer;
		if(layer === void || layer == 'message') return currentNum;
		return +layer.substr(7);
	}

	function setCurrentMessageLayer(elm)
	{
		var page = getMessageLayerPageFromElm(elm);
		var num = getMessageLayerNumberFromElm(elm);
		currentNum = num;
		current = this[page].getMessage(num);
	}

	function process (file,label)
	{
		kagController.jumpTo(file,label);
	}

	function assignBacklay () {
		back.assign(fore);
	}

	function playSE (sefile,sebuf=0) 
	{
		// body...
	}

	function beginTransition (method,time)
	{
		if (method == "crossfade") 
		{
			Actions.run(fore,TRANS_CROSSFADE,time,0);
			back.visible = true;
			back.opacity = 255;
		}
	}

	function waitClick (mode) 
	{
		//mode: 0:[s] 1:[waitclick] 2:[l] 3:[p] 
		skipByClick = false;
	}

	function onTransitionFinished () 
	{
		var base = back;
		back = fore;
		fore = base;
		back.absolute = 0;
		back.opacity = 255;
		back.visible = false;
		fore.absolute = 1;
		fore.opacity = 255;
		fore.visible = true;
	}

	function onClick (x,y) 
	{
		if (waitStatus == 1)
		{
			current.textNoWait();
			skipByClick = true;
			kagController.doNext();
		}
	}
}
