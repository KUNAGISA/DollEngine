
class App extends Window
{
	//tag
	var tagManager; //KAGParser

	//画面管理
	var back = []; //里层配置
	var width;//画面宽高
	var height;

	//剧本表现
	var deffont = %[]; //默认字体设置
	var deffontChanged = true;//默认字体是否有过变化
	var history = void; //历史记录的管理器
	var currentLayer = "message0";//默认

	var transTimer = void; //trans用的Timer
	var moveActions = [];
	var moveWaits = [];
	var moveWaitTime = 0;
	var actionManager = void; //全部action的管理器
	var touch = void;

	//音频管理
	var bgmBuffer = void;
	var seBuffers = %[];

	//状态数据
	var status = %[
		trans : 0,//trans的过渡时长
		transReady : false, //是否进行过trans准备（backlay）
		uiPage : 'fore', //UI控件将被创建在back层还是fore层

		delay : 200,//文字显示速度
		nowait : false, //是否瞬间显示文本/按钮
		clickskip : false, //是否允许点击略过
		locklink : false, //禁止Message层的按钮被点击

		waitClickMode : 0,//0 不等待，1等待文字，2等待移动 3等待trans 4等待时间
		isClickSkip : false,//是否点击之后skip动画中
	];


	function App () 
	{
		super.Window();
		if(global.App.main) {
			em("不可重复创建App");
		}
		global.App.main = this;
		this.width = DEConfig.device.width;
		this.height = DEConfig.device.height;
		this.initialize(DEConfig.device.width,DEConfig.device.height,DEConfig.device.scale);
		this.title = DEConfig.game.title;
		this.tagManager = new TagHandlers(this);
		
		this.world = new GameWorld();
		this.world.initialize(DEConfig.device.width,DEConfig.device.height);

		this.history = new History();
		this.actionManager = new ActionManager();

		this.touch = new Touch();
		this.touch.onMouseDown = this.onMouseDown;
		this.touch.onMouseMove = this.onMouseMove;
		this.touch.onMouseUp = this.onMouseUp;
		this.touch.onClick = this.onClick;
		this.touch.global = true;
		this.touch.enabled = true;
	}

	function finalize () 
	{
		global.App.main = void;
		invalidate this.tagManager;
		invalidate this.history;
		invalidate this.world;
		if (typeof global.kag != 'undefined') {
			invalidate kag;
		}
		super.finalize();
	}

	/*图层管理*/

	function getCurrentLayer () 
	{
		if (this.status.uiPage == 'back') {
			return void;
		}
		return getLayerByElm(%[layer:this.currentLayer]);
	}

	function getLayerByElm (elm) 
	{
		var p=elm.page,layer=elm.layer;
		if (p == 'back') {
			return void;
		}
		else {
			var lay;
			var msgIdx = -1;
			if (layer.indexOf('message') == 0) {
				layer = 'message0' if layer == 'message';
				msgIdx = +layer.substr(7);
				if (msgIdx == 0 && layer != 'message0') {
					layer = 'message0';
				}
				else if(msgIdx < 0){
					msgIdx = 0;
					layer = 'message0';
				}
			}
			if (typeof this.world.names[layer] == 'undefined') {
				var zorder=0;
				if(msgIdx>=0)
				{
					lay = new MessageLayer(this.world);
					zorder=1000000+1000*msgIdx;
					this.world.messages[msgIdx] = lay;
				}
				else if(layer == 'base'){
					lay = new GraphicLayer(this.world);
					zorder = -1;
					this.world.base = lay;
				}
				else if(layer!='0'&&+layer==0){
					lay = new MessageLayer(this.world);
					zorder = 0;
				}
				else {
					lay = new GraphicLayer(this.world);
					zorder=1000*layer;
					this.world.layers[+layer] = lay;
				}
				lay.absolute = zorder;
				this.world.names[layer] = lay;
			}
			else {
				lay = this.world.names[layer];
			}
			return lay;
		}
	}


	function clearLayers () 
	{
		this.world.clearLayers();
	}


	/*音频控制*/

	function getBGM () 
	{
		if (this.bgmBuffer == void) {
			this.bgmBuffer = new BGMBuffer();
		}
		return this.bgmBuffer;
	}

	function getSE (buf=0) 
	{
		var se = this.seBuffers[buf];
		if (se == void) {
			se = new SEBuffer();
			se.buf = buf;
			this.seBuffers[buf] = se;
		}
		return se;
	}

	/*TAG控制*/

	function checkElm (elm,arr) 
	{
		for (var i = 0; i < arr.count; i++) {
			if(typeof elm[arr[i]] == 'undefined'){
				em("必须的参数 %s 不存在",arr[i]);
			}
		};
	}

	function mergerBack (tag, elm) 
	{
		var telm = %[];
		(Dictionary.assignStruct incontextof telm)(elm);
		telm.page = 'fore';
		telm.cond = void;
		this.back.add([tag,telm]);
	}

	function proccess (file, label) 
	{
		this.tagManager.jumpTo(file,label);
	}

	/**********场景切换*********/

	function beginTransition (isblack) 
	{
		super.beginTransition(isblack);
		if (this.status.transReady == false) {
			this.clearLayers();
		}
		var count = this.back.count;
		for (var i = 0; i < count; i++) {
			this.tagManager.onExecute(this.back[i][0],this.back[i][1]);
		};
		this.back.clear();
		this.status.transReady = false;
	}

	function transWithMethod (method,time) 
	{
		if (!this.transTimer) {
			this.transTimer = new Timer();
			this.transTimer.interval = 0;
		}
		this.transTimer.enabled = false;
		switch(method)
		{
			case 'crossfade':
			{
				this.beginTransition(true);
				this.transTimer.handler = this.onTransCrossFadeUpdate;
			}
			break;
			default:
			{
				dm('未实现的trans模式',method);
				return;
			}
				break;
		}
		this.status.trans = time;
		this.status.transT = 0;
		this.transTimer.enabled = true;
	}

	function onTransCrossFadeUpdate (timer) 
	{
		var dt = this.status.transT/this.status.trans;
		// var dt = timer.time*1000/this.status.trans;
		this.transWithCrossFade(dt);
		if (dt >= 1) {
			timer.enabled = false;
			this.transFinished();
		}
		this.status.transT += 1/60;
	}

	function onMouseDown(x,y)
	{

	}

	function onMouseMove(x,y)
	{

	}

	function onMouseUp(x,y)
	{
		switch(this.status.waitClickMode) {
			case 0:
			break;
			case 1:
			{
				//等待文字
				this.status.isClickSkip = true;
			}
			break;
			case 2:
			{
				//等待move
				for (var i = this.moveActions.count - 1; i >= 0; i--) {
					var act = this.moveActions[i];
					if (isvalid act && !act.released ) {
						act.update(1);
						invalidate act;
					}
				}
				this.moveActions.clear();
				this.moveWaits.clear();
				this.tagManager.doNext();
			}
			break;
			case 3:
			{
				//等待trans
				this.status.transT=this.status.trans;
			}
			break;
			case 4:
			{
				//等待时间
				this.tagManager.doNext();
			}
			break;
		}
	}

	function onClick(x,y)
	{

	}

	/*******TAG部分*******/
	var tagHandlers = %[

		/*******无效的指令*******/
		laycount : function () {dm('失效的指令');} incontextof this,
		loadplugin : function () {dm('失效的指令');} incontextof this,
		mappfont : function () {dm('失效的指令');} incontextof this,
		rclick : function () {dm('失效的指令');} incontextof this,

		/*******系统操作*******/

		//执行表达式
		eval : function (elm) 
		{
			if (elm.exp) {
				Scripts.eval(elm.exp);
			}
		} incontextof this,

		iscript : function (elm) 
		{
			Scripts.exec(elm.exp);
		} incontextof this,

		endscript : function (elm) 
		{
		} incontextof this,


		/*******剧本控制*******/
		call : function (elm) 
		{
			this.tagManager.callLabel(elm.storage,elm.target);
			return -1;
		} incontextof this,

		jump : function (elm) 
		{
			this.tagManager.jumpTo(elm.storage,elm.target);
			return -1;
		} incontextof this,

		endmacro : function () 
		{
			this.tagManager.returnMacro();
			return -1;
		} incontextof this,

		wait : function (elm) 
		{
			checkElm(elm,['time']);
			this.status.waitClickMode = 4;
			return elm.time;
		} incontextof this,

		wt : function (elm) 
		{
		} incontextof this,

		deffont : function (elm) 
		{
			merger(this.deffont,elm);
			this.deffontChanged = true;
		} incontextof this,

		history : function (elm) 
		{
			this.history.enabled = elm.enabled if elm.enabled !== void;
		} incontextof this,

		s : function (elm) 
		{
			return -2;
		} incontextof this,

		clickskip : function (elm) 
		{
			this.status.clickskip = elm.enabled if elm.enabled!==void;
		} incontextof this,

		locklink : function (elm) 
		{
			this.status.locklink = true;
		} incontextof this,

		unlocklink : function (elm) 
		{
			this.status.locklink = false;
		} incontextof this,

		/*******音频控制*******/
		bgmopt : function (elm)
		{
			this.getBGM().volume = elm.volume if elm.volume !== void;
		} incontextof this,

		seopt : function (elm)
		{
			var se = this.getSE(elm.buf);
			se.volume = elm.volume if elm.volume!==void;
			se.pan = elm.pan if elm.pan!==void;
		} incontextof this,

		fadeinbgm : function (elm) 
		{
			checkElm(elm,['storage','time']);
			elm.loop = true if elm.loop===void;
			var bgm = this.getBGM();
			bgm.preload(elm.storage);
			bgm.fadeTime = elm.time/1000;
			bgm.play(elm.loop,true);
		} incontextof this,

		fadeoutbgm : function (elm) 
		{
			checkElm(elm,['time']);
			this.getBGM().fadeTime = elm.time/1000;
			this.getBGM().stop(true);
		} incontextof this,

		/*******界面控制*******/
		//创建界面@ui storage=xx layer=xx page=xx visible=xx data=xx
		ui : function (elm) 
		{
			checkElm(elm,['layer','storage']);
			if (elm.page == 'back') {
				this.mergerBack('ui',elm);
				return;
			}
			if (typeof this.world.names[elm.layer] != 'undefined') {
				em('重复的UI %s',elm.layer);
				return -2;
			}
			var uipath = Storages.getFullPath(elm.storage);
			if (!uipath) {
				print("[loadui]ui配置文件%s未找到",uipath);
				return;
			}
			if (typeof elm.hd == 'undefined') {
				elm.hd = true;
			}
			var lay = UIReader.readJsonFile(uipath,this.world,elm.hd);
			this.world.names[elm.layer] = lay;
			lay.visible = elm.visible if elm.visible !== void;
			if (typeof lay.initialize != 'undefined') {
				if (elm.data) {
					var data = Scripts.eval(elm.data);
					lay.initialize(data);
				}
				else {
					lay.initialize();
				}
				lay.refresh();
				if (elm.anim) {
					lay.playShow();
				}
			}
			print("UI %s 创建成功",elm.storage);
		} incontextof this,

		image : function (elm) 
		{
			this.checkElm(elm,['layer','storage']);
			var lay = this.getLayerByElm(elm);
			if(!lay) {
				this.mergerBack('image',elm);
				return;
			}
			if (!(lay instanceof "Sprite")) {
				em("image指令只能操作Sprite类对象");
				return -2;
			}
			lay.loadImages(elm.storage);
			var x = elm.left;
			var y = lay.parent.height-elm.top;
			lay.setPos(x,y);
			lay.visible = elm.visible if elm.visible!==void;
		} incontextof this,

		freeimage : function (elm) 
		{
			this.checkElm(elm,['layer']);
			var lay = this.getLayerByElm(elm);
			if(!lay) {
				this.mergerBack('freeimage',elm);
				return;
			}
			if (!(lay instanceof "Sprite")) {
				em("image指令只能操作Sprite类对象");
				return -2;
			}
			lay.freeImage();
		} incontextof this,

		clearlayers : function (elm) 
		{
			if (elm.page == 'back') {
				this.mergerBack('clearlayers',elm);
				this.status.transReady = false;
				return;
			}
			this.clearLayers();
		} incontextof this,

		layopt : function (elm) 
		{
			this.checkElm(elm,['layer']);
			var lay = this.getLayerByElm(elm);
			if(!lay) {
				this.mergerBack('layopt',elm);
				return;
			}
			lay.visible = elm.visible if elm.visible!==void;
			lay.x = elm.left if elm.left!==void;
			lay.y = lay.parent.height - elm.top if elm.top!==void;
			lay.opacity = elm.opacity if elm.opacity!==void;
			lay.absolute = elm.index if elm.index!==void;
		} incontextof this,

		position : function (elm) 
		{
			this.checkElm(elm,['layer']);
			var lay = this.getLayerByElm(elm);
			if(!lay) {
				this.mergerBack('position',elm);
				return;
			}
			if (lay instanceof "MessageLayer") {
				lay.setPosition(elm);
			}
			else {
				em("position指令只能操作MessageLayer类对象");
				return -2;
			}
		} incontextof this,

		current : function (elm) 
		{
			this.checkElm(elm,['layer']);
			if (elm.page == 'back') {
				this.status.uiPage = 'back';
				this.mergerBack('current',elm);
			}
			else {
				this.status.uiPage = 'fore';
			}
			this.currentLayer = elm.layer;
		} incontextof this,

		er : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if (!lay) {
				this.mergerBack('er',elm);
				return;
			}
			lay.clearEr();
		} incontextof this,

		csysbutton : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if (!lay) {
				this.mergerBack('csysbutton',elm);
				return;
			}
			lay.clearEr(true);
		} incontextof this,

		delay : function (elm) 
		{
			this.checkElm(elm,['speed']);
			this.status.delay = elm.speed;
		} incontextof this,

		nowait : function (elm) 
		{
			this.status.nowait = true;
		} incontextof this,

		endnowait : function (elm) 
		{
			this.status.nowait = false;
		} incontextof this,

		locate : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if(!lay) {
				this.mergerBack('locate',elm);
				return;
			}
			lay.locateX = elm.x if elm.x!==void;
			lay.locateY = elm.y if elm.y!==void;
		} incontextof this,

		button : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if(!lay) {
				this.mergerBack('button',elm);
				return;
			}
			elm.issys = false;
			elm.x = lay.locateX;
			elm.y = lay.locateY;
			lay.addButton(elm);
			if (this.status.nowait) {
				return 0;
			}
			return this.status.delay;
		} incontextof this,

		ch : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if(!lay) {
				this.mergerBack('ch',elm);
				return;
			}
			var pos = lay.addText(elm.text,lay.locateX,lay.locateY);
			lay.locateX = pos[0];
			lay.locateY = pos[1];
			if (pos[2] == true) {
				//点击等待换页
				return -2;
			}
			if (this.status.nowait) {
				return 0;
			}
			this.status.waitClickMode = 1;
			return this.status.delay;
		} incontextof this,

		/*******效果控制*******/
		backlay : function () 
		{
			this.back.clear();
			this.status.transReady = true;
		} incontextof this,

		trans : function (elm) 
		{
			this.checkElm(elm,['method']);
			var time = 1;
			time = elm.time/1000 if elm.time!==void;
			this.transWithMethod(elm.method, time);
			this.status.waitClickMode = 3;
			return elm.time;
		} incontextof this,

		move : function (elm) 
		{
			this.checkElm(elm,['layer','path','time']);
			var lay = this.getLayerByElm(elm);
			if(!lay) {
				this.mergerBack('move',elm);
				return;
			}
			var time = elm.time/1000;
			var path = elm.path;
			path = path.substr(1,path.length-2);
			var paths = path.split(")(");

			//瞬间处理
			if (elm.time == 0) {
				var cfg = paths[-1].split(",");
				lay.setPos(cfg[0],lay.parent.height-cfg[1]);
				lay.opacity = cfg[2];
				return;
			}

			//持续一段时间的处理
			var arr1 = [];
			var arr2 = [];
			for (var i = 0; i < paths.count; i++) {
				var cfg = paths[i].split(",");
				var y = lay.parent.height - cfg[1];
				var mv = new MoveTo(lay,time/paths.count,+cfg[0],y);
				var fd = new FadeTo(lay,time/paths.count,+cfg[2]);
				arr1.add(mv);
				arr2.add(fd);
			};
			var s1 = new Sequence(arr1);
			var s2 = new Sequence(arr2);
			var s3 = new Spawn([s1,s2]);
			var s4 = new Sequence([s3]);
			s4.second = new CallFunc(function () 
			{
				this[0].moveActions.remove(this[1]);
				this[0].moveWaits.remove(this[1]);
			} incontextof [this,s4]);
			this.moveActions.add(s4);
			this.moveWaits.add(s4);
			lay.runAction(s4);

		} incontextof this,

		wm : function (elm) 
		{
			if (this.moveWaits.count == 0) {
				return 0;
			}
			else {
				var act = this.moveWaits[0];
				if (!isvalid act) {
					this.moveWaits.erase(0);
					return 0;
				}
				var t = Math.max(0,(act.duration - act.time));
				this.moveWaits.erase(0);
				this.status.waitClickMode = 2;
				return t*1000;
			}
		} incontextof this,
	];
}

App.main = void;