
class Application
{
	//窗口
	var window;
	var world;

	//画面管理
	var back = []; //里层配置
	var width;//画面宽高
	var height;
	var actionManager = void; //全部action的管理器
	var touch = void;
	var transTimer = void; //trans用的Timer

	//剧本表现
	var deffont = %[]; //默认字体设置
	var deffontChanged = true;//默认字体是否有过变化
	var history = void; //历史记录的管理器
	var currentLayer = "message0";//默认

	//tag
	var tagManager; //KAGParser
	var moveWaits = [];
	var actionWaits = [];

	//音频管理
	var bgmBuffer = void;
	var seBuffers = %[];

	//状态数据
	var status = %[
		transDuration : 0,//trans的过渡时长
		transT : 0,//当前trans到多少时间
		transReady : false, //是否进行过trans准备（backlay）
		uiPage : 'fore', //UI控件将被创建在back层还是fore层

		delay : 200,//文字显示速度
		nowait : false, //是否瞬间显示文本/按钮
		clickskip : false, //是否允许点击略过
		locklink : false, //禁止Message层的按钮被点击
		/*
		0 不等待
		1 等待文字
		2 等待移动
		3 等待trans 
		4 等待时间
		5 等待点击继续文字
		6 等待点击换页
		*/
		waitClickMode : WAIT_CLICK_NONE,
		isClickSkip : false,//是否点击之后skip动画中
		clickToNext : false,//是否刚刚点击继续过（用于过滤r）
	];


	function Application () 
	{
		if(typeof System.main != 'undefined') {
			em("不可重复创建Application");
		}
		System.main = this;
		

		this.window = new Window();
		window.width = DEConfig.device.width;
		window.height = DEConfig.device.height;
		window.title = DEConfig.game.title;
		window.initialize(DEConfig.device.width,DEConfig.device.height,DEConfig.device.scale);
		
		this.world = new GameWorld();
		this.world.initialize(DEConfig.device.width,DEConfig.device.height);
		window.world = this.world;
		window.onVisit = world.visit;

		this.tagManager = new TagHandlers(this);
		
		this.history = new History();

		this.actionManager = new ActionManager();

		this.touch = new Touch();
		this.touch.onMouseDown = this.onMouseDown;
		this.touch.onMouseMove = this.onMouseMove;
		this.touch.onMouseUp = this.onMouseUp;
		this.touch.onClick = this.onClick;
		this.touch.global = true;
		this.touch.enabled = true;
	}

	function finalize () 
	{
		System.main = void;
		invalidate this.tagManager;
		invalidate this.history;
		invalidate this.world;
		invalidate window;
	}

	/*图层管理*/

	function getCurrentLayer () 
	{
		if (this.status.uiPage == 'back') {
			return void;
		}
		return getLayerByElm(%[layer:this.currentLayer]);
	}

	function getLayerByElm (elm) 
	{
		var p=elm.page,layer=elm.layer;
		if (p == 'back') {
			return void;
		}
		else {
			var lay;
			var msgIdx = -1;
			if (layer.indexOf('message') == 0) {
				layer = 'message0' if layer == 'message';
				msgIdx = +layer.substr(7);
				if (msgIdx == 0 && layer != 'message0') {
					layer = 'message0';
				}
				else if(msgIdx < 0){
					msgIdx = 0;
					layer = 'message0';
				}
			}
			if (typeof this.world.names[layer] == 'undefined') {
				var zorder=0;
				if(msgIdx>=0)
				{
					lay = new MessageLayer(this.world);
					zorder=1000000+1000*msgIdx;
					this.world.messages[msgIdx] = lay;
				}
				else if(layer == 'base'){
					lay = new GraphicLayer(this.world);
					zorder = -1;
					this.world.base = lay;
				}
				else if(layer!='0'&&+layer==0){
					lay = new MessageLayer(this.world);
					zorder = 0;
				}
				else {
					lay = new GraphicLayer(this.world);
					zorder=1000*layer;
					this.world.layers[+layer] = lay;
				}
				lay.absolute = zorder;
				this.world.names[layer] = lay;
			}
			else {
				lay = this.world.names[layer];
			}
			return lay;
		}
	}


	function clearLayers () 
	{
		this.world.clearLayers();
	}


	/*音频控制*/

	function getBGM () 
	{
		if (this.bgmBuffer == void) {
			this.bgmBuffer = new BGMBuffer();
		}
		return this.bgmBuffer;
	}

	function getSE (buf=0) 
	{
		var se = this.seBuffers[buf];
		if (se == void) {
			se = new SEBuffer();
			se.buf = buf;
			this.seBuffers[buf] = se;
		}
		return se;
	}

	/*TAG控制*/

	function checkElm (elm,arr) 
	{
		for (var i = 0; i < arr.count; i++) {
			if(typeof elm[arr[i]] == 'undefined'){
				em("必须的参数 %s 不存在",arr[i]);
			}
		};
	}

	function mergerBack (tag, elm) 
	{
		var telm = %[];
		(Dictionary.assignStruct incontextof telm)(elm);
		telm.page = 'fore';
		telm.cond = void;
		this.back.add([tag,telm]);
	}

	function process (file, label) 
	{
		this.tagManager.process(file,label);
		this.tagManager.execTags();
		// action.async(function () 
		// {
		// 	this.tagManager.execTags();
		// } incontextof this.tagManager);
	}

	/**********场景切换*********/

	function beginTransition (isblack) 
	{
		window.beginTransition(isblack);
		if (this.status.transReady == false) {
			this.clearLayers();
		}
		var count = this.back.count;
		for (var i = 0; i < count; i++) {
			this.tagManager.onExecute(this.back[i][0],this.back[i][1]);
		};
		this.back.clear();
		this.status.transReady = false;
	}

	function transWithMethod (method,time) 
	{
		if (!this.transTimer) {
			this.transTimer = new Timer();
			this.transTimer.interval = 0;
		}
		this.transTimer.enabled = false;
		switch(method)
		{
			case 'crossfade':
			{
				this.beginTransition(true);
				this.transTimer.handler = this.onTransCrossFadeUpdate;
			}
			break;
			default:
			{
				dm('未实现的trans模式',method);
				return;
			}
				break;
		}
		this.status.transDuration = time;
		this.status.transT = 0;
		this.transTimer.enabled = true;
	}

	function onTransCrossFadeUpdate (timer) 
	{
		var dt = this.status.transT/this.status.transDuration;
		// var dt = timer.time*1000/this.status.trans;
		window.transWithCrossFade(dt);
		if (dt >= 1) {
			timer.enabled = false;
			window.transFinished();
		}
		this.status.transT += 1/60;
	}

	function clickToNext () 
	{
		this.status.clickToNext = true;
		this.tagManager.doNext();
	}

	function clickToNextCh () 
	{
		var lay = getCurrentLayer();
		if (!lay) {
			dm("指令l在点击时，当前图层应该是表层");
			return;
		}
		clickToNext();
	}

	function clickToNextPage () 
	{
		var lay = getCurrentLayer();
		if (!lay) {
			dm("指令p在点击时，当前图层应该是表层");
			return;
		}
		lay.clearWord();
		lay.locateX = 0;
		lay.locateY = 0;
		clickToNext();
	}

	function onMouseDown(x,y)
	{
		switch(this.status.waitClickMode) {
			case WAIT_CLICK_NONE:
			break;
			case WAIT_CLICK_WORD:
			{
				//等待文字
				this.status.isClickSkip = true;
			}
			break;
			case WAIT_CLICK_MOVE:
			{
				//等待move
				for (var i = this.moveWaits.count - 1; i >= 0; i--) {
					var act = this.moveWaits[i];
					if (isvalid act) {
						act.update(1);
						act.onActionEnded();
						invalidate act;
					}
				}
				this.moveWaits.clear();
				this.tagManager.doNext();
			}
			break;
			case WAIT_CLICK_TRANS:
			{
				//等待trans
				this.status.transT=this.status.transDuration;
			}
			break;
			case WAIT_CLICK_TIME:
			{
				//等待时间
				clickToNext();
			}
			break;
			case WAIT_CLICK_L:
			{
				//等待点击继续文字
				clickToNextCh();
			}
			break;
			case WAIT_CLICK_P:
			{
				//等待点击换页
				clickToNextPage();
			}
			break;
			case WAIT_CLICK_ACTION:
			{
				//等待动作结束
				for (var i = this.actionWaits.count - 1; i >= 0; i--) {
					var act = this.actionWaits[i];
					if (isvalid act) {
						act.update(1);
						act.onActionEnded();
						invalidate act;
					}
				}
				this.actionWaits.clear();
				this.tagManager.doNext();
			}
			break;
		}
	}

	function onMouseMove(x,y)
	{

	}

	function onMouseUp(x,y)
	{
	}

	function onClick(x,y)
	{

	}

	/*******TAG部分*******/
	var tagHandlers = %[

		/*******无效的指令*******/
		laycount : function () {print('失效的指令laycount');} incontextof this,
		loadplugin : function () {print('失效的指令loadplugin');} incontextof this,
		mappfont : function () {print('失效的指令mappfont');} incontextof this,
		rclick : function () {print('失效的指令rclick');} incontextof this,

		/*******系统操作*******/

		//执行表达式
		eval : function (elm) 
		{
			if (elm.exp) {
				Scripts.eval(elm.exp);
			}
		} incontextof this,

		iscript : function (elm) 
		{
			Scripts.exec(elm.exp);
		} incontextof this,

		endscript : function (elm) 
		{
		} incontextof this,


		/*******剧本控制*******/
		call : function (elm) 
		{
			this.tagManager.callStorage(elm.storage,elm.target);
			return -1;
		} incontextof this,

		jump : function (elm) 
		{
			this.tagManager.process(elm.storage,elm.target);
			return -1;
		} incontextof this,

		wait : function (elm) 
		{
			checkElm(elm,['time']);
			this.status.waitClickMode = WAIT_CLICK_TIME;
			return elm.time;
		} incontextof this,

		wt : function (elm) 
		{
		} incontextof this,

		deffont : function (elm) 
		{
			merger(this.deffont,elm);
			this.deffontChanged = true;
		} incontextof this,

		history : function (elm) 
		{
			this.history.enabled = elm.enabled if elm.enabled !== void;
		} incontextof this,

		s : function (elm) 
		{
			return -2;
		} incontextof this,

		clickskip : function (elm) 
		{
			this.status.clickskip = elm.enabled if elm.enabled!==void;
		} incontextof this,

		locklink : function (elm) 
		{
			this.status.locklink = true;
		} incontextof this,

		unlocklink : function (elm) 
		{
			this.status.locklink = false;
		} incontextof this,

		l : function (elm) 
		{
			var lay = getCurrentLayer();
			if (!lay) {
				this.mergerBack('l',elm);
				return;
			}
			this.status.waitClickMode = WAIT_CLICK_L;
			return -2;
		} incontextof this,

		p : function (elm) 
		{
			var lay = getCurrentLayer();
			if (!lay) {
				this.mergerBack('p',elm);
				return;
			}
			this.status.waitClickMode = WAIT_CLICK_P;
			return -2;
		} incontextof this,

		/*******音频控制*******/
		bgmopt : function (elm)
		{
			this.getBGM().volume = elm.volume if elm.volume !== void;
		} incontextof this,

		seopt : function (elm)
		{
			var se = this.getSE(elm.buf);
			se.volume = elm.volume if elm.volume!==void;
			se.pan = elm.pan if elm.pan!==void;
		} incontextof this,

		fadeinbgm : function (elm) 
		{
			checkElm(elm,['storage','time']);
			elm.loop = true if elm.loop===void;
			var bgm = this.getBGM();
			bgm.preload(elm.storage);
			bgm.fadeTime = elm.time/1000;
			bgm.play(elm.loop,true);
		} incontextof this,

		fadeoutbgm : function (elm) 
		{
			checkElm(elm,['time']);
			this.getBGM().fadeTime = elm.time/1000;
			this.getBGM().stop(true);
		} incontextof this,

		playse : function (elm) 
		{
			checkElm(elm,['storage']);
			var se = this.getSE(elm.buf);
			se.preload(elm.storage);
			se.play(elm.loop,false);
		} incontextof this,

		/*******界面控制*******/
		//创建界面@ui storage=xx layer=xx page=xx visible=xx data=xx
		ui : function (elm) 
		{
			checkElm(elm,['layer','storage']);
			if (elm.page == 'back') {
				this.mergerBack('ui',elm);
				return;
			}
			if (typeof this.world.names[elm.layer] != 'undefined') {
				em('重复的UI %s',elm.layer);
				return -2;
			}
			var uipath = Storages.getFullPath(elm.storage);
			if (!uipath) {
				print("[loadui]ui配置文件%s未找到",uipath);
				return;
			}
			if (typeof elm.hd == 'undefined') {
				elm.hd = true;
			}
			var lay = UIReader.readJsonFile(uipath,this.world,elm.hd);
			this.world.names[elm.layer] = lay;
			lay.visible = elm.visible if elm.visible !== void;
			if (typeof lay.initialize != 'undefined') {
				if (elm.data) {
					var data = Scripts.eval(elm.data);
					lay.initialize(data);
				}
				else {
					lay.initialize();
				}
				lay.refresh();
				if (elm.anim) {
					lay.playShow();
				}
			}
			print("UI %s 创建成功",elm.storage);
		} incontextof this,

		image : function (elm) 
		{
			this.checkElm(elm,['layer','storage']);
			var lay = this.getLayerByElm(elm);
			if(!lay) {
				this.mergerBack('image',elm);
				return;
			}
			if (!(lay instanceof "Sprite")) {
				em("image指令只能操作Sprite类对象");
				return -2;
			}
			lay.loadImages(elm.storage);
			var x = elm.left;
			var y = lay.parent.height-elm.top;
			lay.setPos(x,y);
			lay.scale = 1;
			lay.visible = elm.visible if elm.visible!==void;
			lay.absolute = elm.index if elm.index!==void;
		} incontextof this,

		freeimage : function (elm) 
		{
			this.checkElm(elm,['layer']);
			var lay = this.getLayerByElm(elm);
			if(!lay) {
				this.mergerBack('freeimage',elm);
				return;
			}
			if (!(lay instanceof "Sprite")) {
				em("image指令只能操作Sprite类对象");
				return -2;
			}
			lay.freeImage();
		} incontextof this,

		clearlayers : function (elm) 
		{
			if (elm.page == 'back') {
				this.mergerBack('clearlayers',elm);
				this.status.transReady = false;
				return;
			}
			this.clearLayers();
		} incontextof this,

		layopt : function (elm) 
		{
			this.checkElm(elm,['layer']);
			var lay = this.getLayerByElm(elm);
			if(!lay) {
				this.mergerBack('layopt',elm);
				return;
			}
			lay.visible = elm.visible if elm.visible!==void;
			lay.x = elm.left if elm.left!==void;
			lay.y = lay.parent.height - elm.top if elm.top!==void;
			lay.opacity = elm.opacity if elm.opacity!==void;
			lay.absolute = elm.index if elm.index!==void;
		} incontextof this,

		position : function (elm) 
		{
			this.checkElm(elm,['layer']);
			var lay = this.getLayerByElm(elm);
			if(!lay) {
				this.mergerBack('position',elm);
				return;
			}
			if (lay instanceof "MessageLayer") {
				lay.setPosition(elm);
			}
			else {
				em("position指令只能操作MessageLayer类对象");
				return -2;
			}
		} incontextof this,

		current : function (elm) 
		{
			this.checkElm(elm,['layer']);
			if (elm.page == 'back') {
				this.status.uiPage = 'back';
				this.mergerBack('current',elm);
			}
			else {
				this.status.uiPage = 'fore';
			}
			this.currentLayer = elm.layer;
		} incontextof this,

		er : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if (!lay) {
				this.mergerBack('er',elm);
				return;
			}
			lay.clearEr();
		} incontextof this,

		r : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if (!lay) {
				this.mergerBack('r',elm);
				return;
			}
			if (!lay.locateChangeLine()) {
				if (!app.status.clickToNext) {
					this.status.waitClickMode = WAIT_CLICK_P;
					this.status.isClickSkip = false;
					return -2;
				}
				else {
					lay.clearWord();
				}
			}
			if (this.status.nowait) {
				return 0;
			}
			return this.status.delay;
		} incontextof this,

		csysbutton : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if (!lay) {
				this.mergerBack('csysbutton',elm);
				return;
			}
			lay.clearEr(true);
		} incontextof this,

		delay : function (elm) 
		{
			this.checkElm(elm,['speed']);
			this.status.delay = elm.speed;
		} incontextof this,

		nowait : function (elm) 
		{
			this.status.nowait = true;
		} incontextof this,

		endnowait : function (elm) 
		{
			this.status.nowait = false;
		} incontextof this,

		locate : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if(!lay) {
				this.mergerBack('locate',elm);
				return;
			}
			lay.locateX = elm.x if elm.x!==void;
			lay.locateY = elm.y if elm.y!==void;
		} incontextof this,

		button : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if(!lay) {
				this.mergerBack('button',elm);
				return;
			}
			elm.issys = false;
			elm.x = lay.locateX;
			elm.y = lay.locateY;
			lay.addButton(elm);
			if (this.status.nowait) {
				return 0;
			}
			return this.status.delay;
		} incontextof this,

		ch : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if(!lay) {
				this.mergerBack('ch',elm);
				return;
			}
			var pos = lay.addText(elm.text,lay.locateX,lay.locateY);
			lay.locateX = pos[0];
			lay.locateY = pos[1];
			if (pos[2] == true) {
				this.status.waitClickMode = WAIT_CLICK_P;//点击等待换页
				this.status.isClickSkip = false;
				return -2;
			}
			if (this.status.nowait || this.status.isClickSkip) {
				return 0;
			}
			this.status.waitClickMode = WAIT_CLICK_WORD;
			return this.status.delay;
		} incontextof this,

		slider : function (elm) 
		{
			var lay = this.getCurrentLayer();
			if(!lay) {
				this.mergerBack('slider',elm);
				return;
			}
			elm.issys = false;
			elm.x = lay.locateX;
			elm.y = lay.locateY;
			lay.addSlider(elm);
			if (this.status.nowait) {
				return 0;
			}
			return this.status.delay;
		} incontextof this,

		/*******效果控制*******/
		backlay : function () 
		{
			this.back.clear();
			this.status.transReady = true;
		} incontextof this,

		trans : function (elm) 
		{
			this.checkElm(elm,['method']);
			var time = 1;
			time = elm.time/1000 if elm.time!==void;
			this.transWithMethod(elm.method, time);
			this.status.waitClickMode = WAIT_CLICK_TRANS;
			return elm.time;
		} incontextof this,

		move : function (elm) 
		{
			this.checkElm(elm,['layer','path']);
			var lay = this.getLayerByElm(elm);
			if(!lay) {
				this.mergerBack('move',elm);
				return;
			}
			var time = 1;
			if (elm.time!==void) {
				time = elm.time/1000;
			}
			var path = elm.path;
			path = path.substr(1,path.length-2);
			var paths = path.split(")(");

			//瞬间处理
			if (elm.time == 0) {
				var cfg = paths[-1].split(",");
				lay.setPos(cfg[0],lay.parent.height-cfg[1]);
				lay.opacity = cfg[2];
				return;
			}

			//持续一段时间的处理
			var arr1 = [];
			var arr2 = [];
			for (var i = 0; i < paths.count; i++) {
				var cfg = paths[i].split(",");
				var y = lay.parent.height - cfg[1];
				var mv = new MoveTo(lay,time/paths.count,+cfg[0],y);
				var fd = new FadeTo(lay,time/paths.count,+cfg[2]);
				arr1.add(mv);
				arr2.add(fd);
			};
			var s1 = new Sequence(arr1);
			var s2 = new Sequence(arr2);
			var s3 = new Spawn([s1,s2]);
			s3.onActionEnded = function () 
			{
				this[0].moveWaits.remove(this[1]);
			}incontextof [this,s3];
			this.moveWaits.add(s3);
			lay.runAction(s3);

		} incontextof this,

		action : function (elm) 
		{
			this.checkElm(elm,['layer','module']);
			var lay = this.getLayerByElm(elm);
			if(!lay) {
				this.mergerBack('action',elm);
				return;
			}
			var time = 1;
			if (elm.time!==void) {
				time = elm.time/1000;
			}
			var act;
			if(TagActions[elm.module]){
				act = TagActions[elm.module](lay,time,elm);
			}
			else {
				dm("未实现的tag action",elm.module);
				return;
			}
			act.target = lay;
			act.onActionEnded = function () 
			{
				this[0].actionWaits.remove(this[1]);
			} incontextof [this,act];
			this.actionWaits.add(act);
			lay.runAction(act);
		} incontextof this,

		wact : function (elm) 
		{
			if (this.actionWaits.count == 0) {
				return 0;
			}
			else {
				elm.page = "fore";
				var lay = this.getLayerByElm(elm);
				var act=void;
				for (var i = 0; i < actionWaits.count; i++) {
					if(actionWaits[i].target==lay){
						act = actionWaits[i];
						break;
					}
				}
				if (!act) {
					return 0;
				}
				if (!isvalid act) {
					actionWaits.remove(act);
					return 0;
				}
				var t = Math.max(0,(act.duration - act.time));
				this.actionWaits.remove(act);
				this.status.waitClickMode = WAIT_CLICK_ACTION;
				return t*1000;
			}
		} incontextof this,

		wm : function (elm) 
		{
			if (this.moveWaits.count == 0) {
				return 0;
			}
			else {
				var act = this.moveWaits[0];
				if (!isvalid act) {
					this.moveWaits.erase(0);
					return 0;
				}
				var t = Math.max(0,(act.duration - act.time));
				this.moveWaits.erase(0);
				this.status.waitClickMode = WAIT_CLICK_MOVE;
				return t*1000;
			}
		} incontextof this,
	];

	property fullScreen {
	    setter(v) {
	    	//setter
	    	this.window.fullScreen = v;
		}
		getter {
	    	//getter
			return this.window.fullScreen;
		}
	}
}
