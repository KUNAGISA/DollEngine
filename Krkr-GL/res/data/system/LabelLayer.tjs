
class LabelLayer extends KAGLayer
{
	var labels = [];
	var maxWidth = 100;
	var maxHeight = 100;
	var pages = [];
	var startX = 0;
	var startY = 0;
	var lineSpacing = 10;//行间距
	var charSpacing = 0;//字间距

	var affectIndex;
	var affectShowTimer;
	var nextCharX = 0;
	var nextCharY = 0;
	var lineHeight = 0;

	var ownerElm = void;

	var delegate = void;//委托对象，一般是所在的messageLayer

	function LabelLayer (win,par,ownerElm) 
	{
		super.KAGLayer(...);
		affectShowTimer = new Timer(onShow,"");
		if (!ownerElm)
		{
			throw new Exception("Label必须有个字典作为文字属性的来源");
		}
		this.ownerElm = ownerElm;
	}

	function finalize () {
		invalidate affectShowTimer;
		for (var i = 0; i < labels.count; i++) {
			invalidate labels[i];
		};
		labels.clear();
		super.finalize();
	}

	function assign (src) 
	{
		super.assign(src);
		for (var i = 0; i < labels.count; i++) {
			invalidate labels[i];
		};
		labels.clear();
		maxWidth = src.maxWidth;
		maxHeight = src.maxHeight;
		pages = src.pages;
		startX = src.startX;
		startY = src.startY;
		lineSpacing = src.lineSpacing;
		charSpacing = src.charSpacing;

		affectIndex = src.affectIndex;
		affectShowTimer = src.affectShowTimer;
		nextCharX = src.nextCharX;
		nextCharY = src.nextCharY;
		lineHeight = src.lineHeight;

		for (var i = 0; i < src.labels.count; i++) {
			var src_label = src.labels[i];
			var label = new CharLabel();
			labels.add(label);
			label.object = this;
			label.string = src_label.string;
			label.fontName = ownerElm.fontName;
			label.fontSize = ownerElm.fontSize;
			label.x = src_label.x;
			label.y = src_label.y;
			label.offsetY = src_label.offsetY;
			label.bottom = src_label.bottom;
			label.enabled = true;
		};
	}

	function refresh (pageIndex=0) {
		for (var i = 0; i < labels.count; i++) {
			invalidate labels[i];
		};
		labels.clear();
		var index = 0;
		if (pageIndex > 0) {
		   	index = pages[pageIndex-1];
		}
		nextCharX = startX;
		nextCharY = startY;
		lineHeight = 0;
		for (var i = index; i < text.length; i++) {
			if(text[i] == '\n')
			{
				nextCharX = 0;
				nextCharY += ownerElm.lineSpacing+ownerElm.fontSize;
				continue;
			}
			var label = new CharLabel();
			labels.add(label);
			label.object = this;
			label.string = text[i];
			label.fontName = ownerElm.fontName;
			label.fontSize = ownerElm.fontSize;
			// dm(maxWidth);
			if (nextCharX > maxWidth)
			{
				nextCharX = 0;
				nextCharY += ownerElm.lineSpacing+ownerElm.fontSize;
			}
			label.x = nextCharX;
			label.y = nextCharY;
			lineHeight = Math.max(lineHeight,label.bearingY);
			label.enabled = false;
			nextCharX += label.width+ownerElm.charSpacing;

			if(this.delegate && this.delegate.onAddCharLabel)
			{
				this.delegate.onAddCharLabel(label);
			}
		};
		for (var i = 0; i < labels.count; i++) {
			labels[i].offsetY = lineHeight - labels[i].bearingY;
			labels[i].bottom = labels[i].offsetY+labels[i].imageHeight;
		};
	}

	function onPaint () {
		for (var i = 0; i < labels.count; i++) {
			labels[i].trigger();
		};
	}

	function show (interval=0) 
	{
		affectIndex = 0;
		if (interval <= 0) 
		{
			affectShowTimer.enabled = false;
		   	for (var i = 0; i < labels.count; i++) {
		   		labels[i].enabled = true;
		   	};
		}
		else
		{
			affectShowTimer.interval = interval;
			affectShowTimer.enabled = true;
			labels[affectIndex].enabled = true;
			++affectIndex;
		}
	}

	function onShow () 
	{
		if (affectIndex >= labels.count)
		{
			affectShowTimer.enabled = false;
			window.waitStatus = 0;
			return;
		}
		labels[affectIndex].enabled = true;
		++affectIndex;
	}

	var _text;
	property text
	{
		setter(v)
		{
			if (_text != v) {
			   	_text = v;
			   	refresh();
			}
		}
		getter
		{
			return _text;
		}
	}

	property length
	{
		getter
		{
			return labels.count;
		}
	}
}